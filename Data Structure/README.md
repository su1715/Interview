# Array

배열. 논리적 저장 순서와 물리적 저장순서가 일치한다.

메모리 공간상에서 연속적으로 자리를 차지하고 있다.

인덱스를 알고 있다면 O(1) 의 시간복잡도로 원소에 접근이 가능하다.

삽입 삭제 과정에서는 원소를 연속적으로 이동시켜야하므로 시간복잡도가 O(n)이다.

# LinkedList

앞의 노드가 다음 노드를 가리키며(다음 노드의 위치를 저장하며) 연결되는 자료구조이다.

논리적 주소와 물리적 주소가 다르기 때문에 순회를 통해서만 데이터에 접근할 수 있다.

특정 노드에 접근하거나 검색하는 것은 시간복잡도가 O(n)이지만

삽입 혹은 삭제의 시간복잡도는 O(1) 이다.

# Stack

나중에 들어간 원소가 먼저 나오는 구조 (LIFO)

용례 : 함수의 콜 스택, 연산자 후위 표기법

# Queue

먼저 들어간 원소가 먼저 나오는 구조 (FIFO)

용례 : CPU 스케줄링, bfs 탐색

# Tree

계층 구조를 나타내는 비선형 자료구조

루트 노드를 제외한 노드는 단 하나의 부모만 갖는다.

## 이진트리

자식이 2개 이하인 트리.

각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다. 루트 노드의 레벨은 1이다.

## 완전이진트리

왼쪽에서 차근차근 채워지는 이진 트리이다.

## 포화이진트리

모든 레벨이 모두 채워져 있는 트리이다. 각 레벨별 노드 수는 레벨이 k일 때 2 ^ (k - 1)개 이다.

레벨 별 노드 수는 공비가 2인 등비 수열이라고 할 수 있으므로 모든 레벨 노드 수의 합은 등비수열의 합으로 생각할 수 있다.

최대 레벨이 h일 때 등비수열의 합은

1 + 2 + 2^2 + 2^3 + ... + 2^(k-1) = 1 \* (2^(k-1) - 1) / 2 - 1 = 2^(k - 1) - 1 이다.

# Heap

우선순위 큐에 쓰이는 자료구조로 느슨한 정렬을 이루고 있다.

최소값이나 최대값을 빠르게 찾기 위해 고안된 완전 이진트리이다.

배열에 넣을 때 1번째 인덱스부터 시작되며 중복된 값을 허용한다.

최대(최소)값을 찾으려면 가장 상위에 있는 노드를 꺼낸 후, 가장 끝에 있는 노드를 상위에 넣는다. 그리고 자식 노드들과 비교하면서 더 큰(작은) 자식과 자리를 바꾸는 과정을 반복한다.

새로운 노드를 삽입하려면 우선 맨 마지막에 넣는다. 그리고 부모노드와 비교하여 부모노드가 더 작은(큰)경우 부모 노드와 자리를 바꾸는 과정을 반복한다.

최대값 혹은 최소값을 찾는데 걸리는 시간복잡도는 O(1)이다.

# B Tree & B+ Tree

## B Tree

탐색 성능을 높이기 위해 모든 leaf node가 같은 레벨을 유지하는 트리

자식 node 개수가 2개 이상이며 노드의 key가 1개 이상이다.

node 의 key 가 k라면 자식 노드는 k + 1 개 이다.

node 의 key 는 반드시 정렬된 상태이다.

데이터베이스, 파일 시스템에서 널리 사용되는 자료구조이다.

대량의 데이터는 메모리보다는 블럭단위로 입출력하는 하드디스크 or SSD에 저장하는 것이 알맞다.

한블럭이 1024byte 크기라면 2byte를 읽으나 1024byte를 읽으나 똑같은 입출력 비용이 발생하기 때문에 하나의 노드를 1024byte로 꽉 채우는 것이 입출력 비용에 있어서 효율적이다.

## B+ Tree

실제 DB 인덱싱의 형태.

B Tree 와 유사하지만 연결리스트로 이루어져있다는 차이가 있다.

모든 key, data가 리프노드에 모여있다.

모든 리프노드가 연결리스트 형태를 띄고 있어서 옆에 있는 리프노드를 검사할때 루트노드부터 다시 검사할 필요 없이 리프노드에서 선형 검색을 할 수 있어 시간복잡도가 줄어든다.

# Hash Table

key에 해시함수를 적용하여 나온 hash 값을 index로 활용하여 해당 index에 데이터를 저장하는 방법

해시함수를 이용하여 데이터에 바로 접근할 수 있기 때문에 충돌 문제가 없다면 평균적으로 O(1)의 시간복잡도를 갖는다

하지만 서로 다른 key가 해시값이 같은 경우 충돌이 일어난다.

## 해시충돌 해결법

1. Chaining : 해시값이 같은 데이터를 선형리스트로 연결하는 방법. 특정 해시값에 데이터가 몰릴 경우 효율이 떨어진다.

2. 선형 탐색 : 해시값에서 특정폭을 건너 뛰면서 빈 해시를 찾는 방식. 특정 해시값 주변 버킷이 모두 채워져 있는 primary clustring 문제에 취약하다.

3. 제곱 탐색 : 고정폭이 아닌 1칸 -> 4칸 -> 9칸 -> 16칸 씩 건너 뛰면서 빈 칸은 찾는다. 해시값이 같은 해시들이 들어오면 공간을 많이 확보해놔야 한다.

4. 해시함수 개선

# Trie 트라이 자료구조

일반 트리 자료구조 중 하나로, Digital Tree, Radix Tree, Prefix Tree 로도 불린다.

문자열을 저장하고 탐색하는데 유용한 자료구조이다.

각 노드는 <Key, Value> 맵을 가지고 있다. Key는 하나의 알파벳이 되고, Value는 그 Key에 해당하는 자식 노드가 된다.

루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다는 특징이 있다. 즉, 'DE' 노드의 자손인 'DEAR'와 'DEV'는 'DE-'를 공통 접두어로 가지며, 'P'의 자손인 'POW'와 'PIE'는 'P-'를 공통 접두어로 가진다.

루트 노드는 빈 문자와 연관있다.(특정 문자가 할당되어 있지 않다.)

# 이진 탐색 트리

이진 탐색 트리란 정렬되어있고 중복이 없는 이진 트리를 말한다.

여기서 졍렬 되었다는 말은 왼쪽 서브트리의 노드들이 부모 노드보다 작고 오른쪽 서브트리의 노드들이 부모 노드보다 큰 것을 말한다.

특정 값을 찾을 때 현재 노드가 특정 값보다 크다면 왼쪽 서브 트리를 탐색하면 되고, 현재 노드가 특정 값보다 작다면 오른쪽 서브트리를 탐색하면 된다.

시간 복잡도는 O(h) = O(logn) 이다

## 이진 탐색 트리에 노드 삽입

## 이진 탐색 트리의 노드 삭제

# Tree Map

# Red-Black Tree
