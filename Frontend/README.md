## Virtual DOM

Virtual DOM에 대해 설명하기 위해서는 브라우저의 렌더링 과정을 먼저 설명해야한다.

브라우저는 HTML 코드를 파싱해서 DOM, CSS로 CSSOM 트리를 생성한다.

DOM과 CSSOM 트리로 렌더트리를 생성한다. 렌더트리를 기반으로 레이아웃을 계산하고 페인트 과정을 거친다.

만약 DOM 요소가 변경된다면 렌더트리가 다시 만들어지고 리플로우(레이아웃), 리페인트 과정을 거친다.

이 과정 자체가 매우 오래걸리는 작업은 아니지만 SPA(single page applicatioin) 은 DOM 조작이 매우 잦을 수 있다는 것이 문제이다.

DOM을 조작할 때마다 렌더트리 생성 - 리플로우 - 리페인팅 과정이 반복해서 일어나므로

**한번에 일어나야하는 변화는 Virtual DOM 에 모아서 DOM을 한번만 조작하겠다는 것이 Virtual DOM 이다.**

Virtual DOM의 변경사항이 DOM에 반영될때는 변경된 부분만 확인하여 적용한다. (diffing 알고리즘)

## Babel

자바스크립트 트랜스파일러 (자바스크립트'로' 변환)

최신 문법을 브라우저가 지원하지 못하는 경우, 구 버전의 브라우저를 사용하는 경우, typescript로 코드를 작성한 경우

Babel 통해 브라우저가 지원하는 버전의 자바스크립트 코드로 트랜스파일한다.

## 번들링

모듈들의 의존성을 파악하여 그룹화시켜주는 것. 파일을 한번에 받아오기 때문에 네트워크 지연이 줄어든다.

대표적인 번들러로 webpack 이 있다.

## 코드 스플리팅

번들링으로 인해 하나의 파일이 너무 커지는 경우 문제 발생.

하나의 파일을 전달하고 파싱하고 실행하는데 오랜 시간이 걸린다.

코드 스플리팅을 하면 사용자가 현재 필요로하는 코드만 먼저 로드하여 앱의 성능을 향상시킬 수 있다.

## SPA

Single Page Application 이란 서버로부터 새로운 페이지를 불러오지 않고 현재 페이지를 동적으로 작성하는 어플리케이션

- 라우팅

  SPA에서 라우팅은 해당 url에 해당하는 페이지를 서버로부터 불러오는 것이 아니라, 해당 url에 맞는 컴포넌트들을 렌더링해야한다.

- 컴포넌트

  컴포넌트란 프로그래밍에 있어서 재사용이 가능하고 각각의 독립된 기능을 가진 모듈

## 리액트를 사용하는 이유

2022년 8월 기준 대표적인 JavaScript UI Library 에는 React 와 Vue 가 있다.

Vue도 좋은 라이브러리이지만 TypeScript 지원이 아직 미흡하며, 컴포넌트를 잘게 쪼갤때는 React가 더 낫다고 한다.

뿐만 아니라 React는 적극적으로 큰 업데이트가 자주 일어나기 때문에 앞으로의 발전 가능성이 더 높다고 판단하는 시각도 존재한다

https://ahnheejong.name/articles/why-i-prefer-react-over-vuejs/

## 리액트에서 클래스형과 함수형 컴포넌트의 차이

클래스형 컴포넌트는 lifeCycle 메소드를 사용할 수 있다. 함수형 컴포넌트는 Hook을 통해 lifeCycle 관련 기능을 사용할 수 있는데, 기존 lifeCycle 메소드와는 차이가 있다.

함수형 컴포넌트는 클래스형 컴포넌트보다 훨씬 작성하고 사용하기 간단하다.

## 함수형 컴포넌트를 권장하는 이유

클래스형 컴포넌트에서 this가 변경 가능하기 때문에 예상치 못한 버그가 일어날 수 있다.

클래스형은 상당히 복잡해서 함수형 컴포넌트를 작성하는 것이 가독성이 좋다.

## 컴포넌트가 렌더링되는 조건

1. props 가 변경되었을 때

2. state 가 변경되었을 때

3. Context value 가 변경되었을 때

4. 부모 컴포넌트가 re-render 되었을 때

## react 최적화하기

1. **값비싼** 연산에 대해서는 useMemo와 useCallback 사용하기

2. React.memo() : 부모 컴포넌트가 재렌더링 되더라도 props가 변경되지 않으면 자식 컴포넌트는 재렌더링 되지 않는다.

   - 자식 컴포넌트에게 props를 넘겨줄 때 객체보다는 원시값으로 넘겨주기, 객체로 넘기면 매번 새로운 참조값을 생성하기 때문

3. children props 활용하기 : 부모 컴포넌트로부터 props 를 받지 않지만, 부모 컴포넌트가 렌더링되어서 같이 렌더링될때, children으로 넣음으로써 불필요한 재렌더링을 막을 수 있다.

## Hook

함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할 수 있도록 도와주는 기능들

### useMemo 와 useCallback을 남용해서는 안되는 이유

useMemo와 useCallback은 컴포넌트가 재렌더링 될 때마다 값비싼 연산을 매번 수행하는 것을 막기 위해 사용하는 Hook 들이다.

그렇다고 해서 모든 연산을 useMemo와 useCallback으로 감싸서는 안된다. 해당 hook을 사용하는 것 또한 연산이 추가되기 때문이다.

useMemo를 사용한다면 dependency 배열의 내용이 변경되었는지 검사하여 콜백함수를 실행할지 말지 검사하는 로직이 추가될 것이다.

만약 콜백함수의 연산이 오래걸리는 작업이 아니라면, useMemo를 사용하는 것이 더 성능을 낮출 수 있다.

## CSR, SSR

어느쪽에서 화면을 구성하는가의 분류

- SSR : server side rendering

  서버 측에서 즉시 렌더링 가능한 HTML 파일을 만들어 클라이언트에게 전달하는 방식

  SEO (검색 엔진 최적화) 에 유리하다.

  초기 구동 속도가 빠르다.

- CSR

  클라이언트 측에서 javascript를 통해 HTML 파일을 구성하는 방식

  처음에는 html 파일에 body 밖에 없기 때문에 SEO에 불리하다.

- Next.js

  리액트에서 SSR을 쉽게 사용할 수 있도록 도와주는 프레임워크

  SPA에 SSR과 SSG를 도입함으로써 SEO 문제를 해결하였다.

  페이지 기반 라우팅으로 직관적인 개발 환경을 제공한다.

  별도의 설정 없이도 코드 스플리팅을 지원한다.

## 상태관리를 하는 이유

상태에 맞춰서 화면을 구성하기 위함이다.

- 상태란 무엇인가? 화면을 구성하는 데이터

=> 데이터가 달라지면 화면을 변경해야한다.

=> 데이터가 달라지는 것을 어떻게 알지? or 어떻게 데이터를 달라지게하지? => 상태관리!

## 상태관리 라이브러리 사용하는 이유

리액트에서 상태관리를 하다보면 하위에 있는 어떤 컴포넌트에게 상태를 넘겨주기 위해서 너무 깊이 넘겨야하는 상황이 발생할 수 있다.

또한 상위 요소의 상태를 바꿀 수 있는 함수를 전달하기도 하는데, 이 과정에서 사용하지 않고 넘겨주기만 하는 props가 너무 많이 발생해서 가독성과 상태관리를 저하시킨다.

상태관리 라이브러리를 사용하면, 해당 상태를 사용하는 컴포넌트들만 영향을 받기 때문에 위와 같은 문제를 해결할 수 있다.
