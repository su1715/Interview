# 제너레이터

코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

제너레이터 함수와 일반함수의 차이는 다음과 같다.

1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.

2. 제너레이터 함수는 함수 호출자와 상태를 주고받을 수 있다.
   제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다.

3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
   일반 함수를 호출하면 함수 코드를 일괄실행하고 값을 반환한다. 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 제너레이터 객체를 반환한다.

```javascript
function* getGenerator() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  return 5;
}

const generator = getGenerator();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: 4, done: false }
console.log(generator.next()); // { value: 5, done: true }
console.log(generator.next()); // { value: undefined, done: true }
```

# 얕은 복사 | 깊은 복사 하는 방법 (직접)

자바스크립트에서 값은 원시값과 객체(참조값)로 나누어진다.

원시값을 복사하여 다른 변수에 할당하면 서로 다른 값을 가지게 되지만,

객체를 복사하면 참조값을 복사하여 다른 변수가 가지게 되기 때문에 같은 메모리를 참조하게 된다.

이렇게 복사했음에도 같은 참조를 가지게 되는 것을 얕은 복사라고 한다.

## 깊은 복사를 하는 방법

1. `Object.assign(obj1, obj2)`

   위 메소드를 사용하면 obj2 의 프로퍼티를 복사해 obj1를 넣을 수 있다. 하지만 프로퍼티가 객체인 경우 얕은 복사가 된다.

2. 펼침 연산자

   일반 객체나 이터러블에 대해 사용하면 프로퍼티를 복사해서 넣을 수 있다. 하지만 프로퍼티가 객체인 경우 얕은 복사가 된다.

3. `JSON.stringify()`, `JSON.parse()`

   객체를 문자열로 치환했다가 다시 객체로 변환하기 때문에 새로운 객체를 만들게 되어 깊은 복사를 할 수 있다.

   대신 속도가 느리고 메소드는 JSON으로 처리할 수 없다.

4. 커스텀 재귀 함수

   ```javascript
   const deepCopy = (obj) => {
     if (obj === null || typeof obj !== 'object') {
       return obj;
     }

     const copy = Array.isArray(obj) ? [] : {};
     for (const key of Object.keys(obj)) {
       copy[key] = deepCopy(obj[key]);
     }
     return copy;
   };
   ```

5. `structuredClone()`

   프로토타입 : structuredClone()를 클래스 인스턴스와 함께 사용 하는 경우, strucuted cloning이 객체의 프로토타입 체인을 폐기하므로 반환 값은 일반 객체가 된다.
   함수 : 객체에 함수가 포함되어 있으면 폐기된다.
   복제 불가 : 일부 값, 특히 Error와 DOM 노드는 구조화된 복제가 불가능합니다. 그것은 structuredClone() 예외 에러(throw)의 원인이 된다.

# ES5 vs ES6

ES : ECMAScript 의 약어. JavaScript 의 표준이다.

- let, const : 블록 레벨 스코프

- 화살표 함수 : 함수를 간결하게 나타냄. this 바인딩 하지 않음

- Template literal : 백틱을 사용. 문자열을 동적으로 작성할 때 변수와 문자열을 연결할 필요 없이 한번에 작성

- 클래스

- 모듈

- 프로미스

- default parameter

- 디스트럭쳐링 할당, 펼침 연산자

# 구조 분해 할당 (디스트럭쳐링 할당)

디스트럭처링 할당은 이터러블 또는 객체를 비구조화(,구조 파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

필요한 값만 추출하여 변수에 할당할 때 유용하다.

# 이터러블 (먼소리얏)

ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

ES6 의 순회 가능한 데이터 컬렉션, 즉 베열, 문자열, 유사 배열 객체, DOM 컬렉션 등은 통일된 규약없이 각자 나름의 구조를 가지고 for 문, for ...in문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6 에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ...of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화하였다.

이터레이션 프로토콜에는 이터러블 프로토콜, 이터레이터 프로토콜이 있다. 이중 이터러블 프로토콜을 준수한 객체를 이터러블이라고 한다.

즉 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메소드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.

내장된 생성자 중 iterable 객체를 만들어내는 생성자에는 아래와 같은 것들이 있다.

- String
- Array
- TypedArray
- Map
- Set

# 펼침 연산자

(ES6 부터 도입)

하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

스프레드 문법을 사용할 수 있는 대상은 이터러블과 일반 객체이다.

# 프로토타입

어떤 객체의 상위 객체 역할을 하는 객체.

하위 객체에 공유 프로퍼티를 제공함으로써 객체지향 프로그래밍의 상속을 구현한다.

프로토타입을 상속 받은 하위 객체(인스턴스, 프로토타입)는 상위 객체의 프로퍼티, 메소드를 자신의 것처럼 자유롭게 사용할 수 있다.

생성자 함수 내부에 메소드를 등록하는 경우 인스턴스마다 똑같은 메소드를 갖게 되어 메모리를 불필요하게 낭비한다.

프로토타입에 메소드를 등록하면 하나의 메소드 코드만으로 인스턴스들이 모두 사용할 수 있다.

따라서 프로토타입을 기반으로 하는 상속은 불필요한 중복을 방지한다.

# 이벤트

## 이벤트 등록 방법

1. HTML 요소의 어트리뷰트로 등록

`<input type="button" onclick="alert('alert!');" value="button" />`

2. DOM 노드 객체의 이벤트 핸들러 프로퍼티에 등록 : getElementById 같은 함수로 DOM 노드 객체를 가져올 수 있다.

```javascript
  <input type="button" id="target" value="button" />
  <script>
    const target = document.getElementById('target');
    target.onclick = function(){
      alert('jin seok');
    }
</script>
```

3. addEventListener 사용

1,2 방식은 이벤트 버블링 단계와 타깃 단계에서만 동작하지만 3 방식은 캡쳐링 단계에서도 동작할 수 있다.

## 이벤트 버블링, 이벤트 캡쳐링

이벤트 버블링 : 한 요소에 이벤트가 발생하면 해당 요소의 핸들러 뿐만 아니라 조상 요소들의 핸들러들 또한 동작하는 현상. 이벤트가 상위 요소로 전파되는 현상. `event.propagation()` 을 사용해 버블링을 중단할 수 있다.

이벤트 캡쳐링 : 이벤트가 하위 요소로 전파되는 현상.

실제로 DOM에서 타깃에 사건이 발생하면 이벤트 객체가 생성되고, 이벤트 캡쳐링 단계와 이벤트 타깃 단계를 거쳐 타깃에 이벤트가 발생한다. 이후 이벤트 버블링 단계를 통해 이벤트가 상위로 전파된다.

## 이벤트 위임

하위 DOM 요소 여러 개에 모두 이벤트 핸들러를 등록하는 대신 상위 DOM 요소 하나에 이벤트 핸들러를 등록하는 것.

이벤트 핸들러를 하위 DOM 요소에 일일이 등록하면 하위 DOM 요소가 많아질수록 성능저하가 일어나고, 유지보수하기 힘들어진다.

이벤트 핸들러로 등록할 함수의 코드가 바뀔때 하위요소의 모든 이벤트 핸들러를 바꿔어야할 필요가 없고,

하위 요소가 새로 생성되거나 삭제 될 때 관리할 필요가 없어진다.

대신 상위 요소의 모든 자식들로부터 이벤트가 발생할 수 있으므로 내가 원하는 하위 요소로부터 발생한 이벤트가 맞는지 확인할 필요가 있다.

# fetch와 axios 차이

fetch 함수가 반환하는 프로미스는 기본적으로 404 not found 나 500 Internal Server Error와 같은 HTTP 에러가 발생해도 에러를 reject 하지 않고 불리언 타입의 ok상태를 false 로 설정한 Response 객체를 resolve 한다. 오프라인 등의 네트워크 장애나 CORS 에러에 의해 요청이 완료되지 못한 경우에만 프로미스를 reject 한다

axios는 모든 HTTP 에러를 reject하는 프로미스를 반환한다. 따라서 모든 에러를 catch에서 처리할 수 있어 편리하다. `또한 axios는 인터셉터, 요청 설정등 fetch보다 다양한 기능을 제공한다.`

# async await

async await는 Promise 를 기반으로 동작하지만 마치 동기 처리처럼 Promise를 사용할 수 있다.

await 키워드는 반드시 async 함수 내부에서 사용해야한다. async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환한다.

await 키워드는 프로미스가 settled 상태가 될때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 promise 앞에서 사용해야한다.

await 키워드는 다음 실행을 일시 중지시켰다가 프로미스가 settled 상태가 되면 다시 재개한다.

# 프로미스

원래 비동기 처리할 때 콜백함수를 사용했는데, 콜백함수를 연속적으로 사용하면 가독성이 떨어지고, 에러 처리가 힘들어서 프로미스가 등장하게 되었다.

비동기 처리에 콜백함수가 필요한 이유 : 비동기 함수는 비동기 처리 결과를 외부에 전달할 수 없기 때문에 콜백 함수를 통해 후속 처리를 한다.

에러 처리 힘든 이유 : 에러는 try .. catch 문으로 처리해주어야하는데, 비동기함수의 콜백함수는 이벤트 루프에 의해 콜스택이 비었을때 콜스택에 들어와 실행되기 때문에 try catch 문 내부에서 처리될 수 없다.

Promise

Promise는 비동기 처리에 사용되는 객체이다. 비동기 처리 함수와 비동기 처리 결과 함수를 연결할 수 있다.

Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.

```jsx
const promise = new Promise((resolve, reject) => {
	// 비동기 처리 수행
	setTimeout(()=>{}, 3000);
	if (/* 비동기 처리 성공 */) {
		resolve('result');
	} else {
		reject('failure reason');
	}
});
```

반환된 Promise는 비동기 처리를 마치면 fullfiled 혹은 rejected 상태가 되는데, 이는 후속처리 메소드인 then과 catch로 결과나 에러를 처리할 수 있다.

```jsx
promise
  .then((res) => console.log(res)) // result
  .catch((e) => console.error(e));
```

# 로컬스토리지와 쿠키의 차이

쿠키 : 웹사이트 접속 시 브라우저에 저장되는 작은 정보 기록 파일. HTTP 는 상태가 없는 연결이기 때문에 쿠키를 통해서 사용자의 과거 이용내역을 알 수 있다.

웹 스토리지 : 로컬 스토리지, 세션 스토리지 (세션이 끝나면 데이터 사라짐)

로컬 스토리지 : 여러 탭을 띄워도 데이터가 서로 공유되며, 창이나 탭을 닫아도 데이터가 유지된다.

세션 스토리지 : 여러 탭을 띄우면 데이터가 따로 저장되며, 창이나 탭을 닫으면 데이터가 사라진다.

쿠키 vs 로컬 스토리지 : 쿠키보다 로컬 스토리지에 저장할 수 있는 용량이 훨씬 크다. 로컬 스토리지에 저장하면 HTTP로 전달되는 데이터가 줄어들어서 전체 트래픽의 양을 줄일 수 있다.

`추가`

# 옵셔널체이닝 연산자 / 단축평가에 대한 설명

옵셔널 체이닝 연산자 (?.) : 참조가 유효한지 명시적으로 검증하지 않고 내부의 속성 값을 읽는 연산자. 만약 참조가 유효하지 않다면(null, undefined) 에러를 발생시키지 않고 undefined 를 반환한다.

단축 평가 : 표현식을 평가하는 도중에 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

if 를 사용해서 false 일 때를 체크해야한다면 `||` 연산자를 사용할 수 있다.

`false || 'hello' === 'hello'`

if 를 사용해서 true 일 때를 체크해야한다면 `&&` 연산자를 사용할 수 있다.

`true && 'hello' === 'hello'`

# 원시값과 객체 비교

원시값 : number, bigInt, string, boolean, undefined, null, symbol

1. 원시값은 변하지 않는다. (만약 변수에 저장한 값이 바뀐다면 변수가 가리키는 메모리의 값이 변경되는 것이 아니라, 다른 메모리에 변경할 값을 저장하고 해당 메모리를 가리키게 한다.) 객체는 내부의 값이 변경될 수 있다.
2. 원시값을 변수에 할당하면 변수에 실제 값이 저장되지만 객체를 변수에 할당하면 변수에 참조값이 저장된다.
3. 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다. 즉 값에 의한 전달이 일어난다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 즉 참조에 의한 전달이 일어난다.

# 브라우저 렌더링 과정

파싱 : 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 구조와 의미를 부여하여 parse Tree 를 생성하는 과정

브라우저의 주소창에 url 을 입력하면 HTML, CSS, javascript 등 렌더링에 필요한 리소스들을 서버에 요청한다. 서버로부터 받은 리소스들은 파싱과정을 거쳐 parsing tree를 형성한다.

HTML은 파싱되어 DOM 트리를 형성하고, CSS은 파싱되어 CSSOM 트리를 형성한다.

DOM 트리와 CSSOM 트리는 결합하여 렌더 트리를 형성한다.

이 렌더 트리를 통해 레이아웃(위치, 크기)을 계산하고 페인팅된다.

만약 자바스크립트가 DOM API로 DOM이나 CSSOM을 변경했다면, DOM 과 CSSOM이 다시 결합하여 렌더 트리를 형성하고 리플로우(레이아웃), 리페인팅 과정을 거친다.

# DOM 이란?

HTML이 파싱되어 브라우저가 이해할 수 있도록 만든 Tree 자료구조이다.

HTML 문서의 계층적 구조와 정보를 포함한다.

# 클로저

클로저는 함수와 그 함수가 선언된 상위 스코프와의 조합이다.

중첩함수가 외부함수보다 오래 유지되는 경우, 중첩 함수는 이미 생명주기가 종료된 외부함수의 변수를 참조할 수 있는데 이 중첩함수를 클로저라고 한다.

# map과 forEach의 차이

map은 배열 내의 모든 요소에 대해 콜백함수를 실행하고 콜백함수가 반환한 값을 새 배열에 넣는다.

forEach는 배열 내의 모든 요소에 대해 콜백함수를 실행한다. 새 배열을 만들지 않는다.

# 일반 함수와 화살표 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없다. (prototype 프로퍼티 x)
2. 화살표 함수는 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.

# this

## this 의 바인딩 방식

javascript 에서 this의 바인딩 방식은 함수를 호출할 때 결정된다.

같은 함수를 선언해도 일반함수로 호출하면 this에 전역객체가 바인딩된다.

(브라우저는 Window, Node.js 는 Global, ‘use strict’ 를 사용하면 undefined)

객체의 메소드로 호출하면 this에 객체가 바인딩된다.

생성자 함수로 호출하면 this에 생성자 함수로 인해 생성된 객체가 바인딩 된다.

## 화살표 함수의 this

화살표 함수는 this가 바인딩 되지 않아 상위 스코프의 this를 사용한다.

# JS는 싱글 스레드인데 비동기가 가능한 이유는?

비동기란 ? 현재 실행중인 태스크가 완료되지 않아도 다음 태스크를 곧바로 실행하는 방식

자바스크립트는 싱글 스레드로 동작하지만 브라우저같은 런타임환경은 멀티 스레드로 동작하기 때문이다. 브라우저나 node.js 같은 런타임 환경에서 이벤트 루프와 태스크 큐를 제공한다.

태스크 큐 : 비동기함수의 콜백함수나 이벤트 핸들러가 일시적으로 보관되는 영역

이벤트 루프 : 콜스택에 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수가 있는지 반복적으로 확인한다. 콜스택에 현재 실행중인 실행 컨텍스트가 없고, 태스크 큐에 대기중인 함수가 있다면 이벤트루프는 순차적(FIFO)으로 태스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다.

# 인터프리터? 컴파일러?

컴파일러 언어는 컴파일 과정을 거쳐 머신코드로 바꾼다음 실행한다. 컴파일 시간이 있지만 실행 시간이 빠르고 그 과정에서 문법 오류나 타입오류를 감지하기 때문에 실행에서 에러를 만날 확률이 줄어든다.

인터프리터 언어는 한줄 한줄을 바이트코드로 바꾼다음 실행한다. 별도의 컴파일 과정이 없어서 바로 실행시켜볼 수 있지만 인터프리트 단계와 실행 단계가 반복적으로 일어나기 때문에 상대적으로 속도가 느리다.

자바스크립트는 별도의 컴파일 과정을 거치지 않는 인터프리터 언어이지만, 모던 자바스크립트 엔진은 컴파일러와 인터프리터의 장점을 결합하여 인터프리터 언어의 속도 문제를 해결했다.

~~자바스크립트엔진은 우선 자바스크립트 코드를 토큰으로 쪼개 AST(abstract syntax tree)라 불리는 추상 트리 구조로 만든다. 이후~~ 인터프리터에서 코드를 바이트 코드로 변환한다. 이 과정에서 최적화할 수 있는 코드를 컴파일(just in time compile)한다.
