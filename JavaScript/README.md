- 최적화한 경험이 있는지 (필자 : API요청 최소화한 사례?)

- event driven과 component driven 의 차이

- OAuth 어떻게 작동하는지? (로그인 구현 어떻게)

- 얕은 복사 | 깊은 복사 하는 방법 (직접)

- ES5 vs ES6

- 쿠키와 세션

- 구조분해할당

- 펼침 연산자

- 이벤트 버블링, 이벤트 캡쳐링

# 제너레이터

# fetch와 axios 차이

fetch 함수가 반환하는 프로미스는 기본적으로 404 not found sk 500 Internal Server Error와 같은 HTTP 에러가 발생해도 에러를 reject 하지 않고 불리언 타입의 ok상태를 false 로 설정한 Response 객체를 resolve 한다. 오프라인 등의 네트워크 장애나 CORS 에러에 의해 요청이 완료되지 못한 경우에만 프로미스를 reject 한다

axios는 모든 HTTP 에러를 reject하는 프로미스를 반환한다. 따라서 모든 에러를 catch에서 처리할 수 있어 편리하다. `또한 axios는 인터셉터, 요청 설정등 fetch보다 다양한 기능을 제공한다.`

# async await

async await는 Promise 를 기반으로 동작하지만 마치 동기 처리처럼 Promise를 사용할 수 있다.

await 키워드는 반드시 async 함수 내부에서 사용해야한다. async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환한다.

await 키워드는 프로미스가 settled 상태가 될때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 promise 앞에서 사용해야한다.

await 키워드는 다음 실행을 일시 중지시켰다가 프로미스가 settled 상태가 되면 다시 재개한다.

# 프로미스

원래 비동기 처리할 때 콜백함수를 사용했는데, 콜백함수를 연속적으로 사용하면 가독성이 떨어지고, 에러 처리가 힘들어서 프로미스가 등장하게 되었다.

비동기 처리에 콜백함수가 필요한 이유 : 비동기 함수는 비동기 처리 결과를 외부에 전달할 수 없기 때문에 콜백 함수를 통해 후속 처리를 한다.

에러 처리 힘든 이유 : 에러는 try .. catch 문으로 처리해주어야하는데, 비동기함수의 콜백함수는 이벤트 루프에 의해 콜스택이 비었을때 콜스택에 들어와 실행되기 때문에 try catch 문 내부에서 처리될 수 없다.

Promise

Promise는 비동기 처리에 사용되는 객체이다. 비동기 처리 함수와 비동기 처리 결과 함수를 연결할 수 있다.

Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.

```jsx
const promise = new Promise((resolve, reject) => {
	// 비동기 처리 수행
	setTimeout(()=>{}, 3000);
	if (/* 비동기 처리 성공 */) {
		resolve('result');
	} else {
		reject('failure reason');
	}
});
```

반환된 Promise는 비동기 처리를 마치면 fullfiled 혹은 rejected 상태가 되는데, 이는 후속처리 메소드인 then과 catch로 결과나 에러를 처리할 수 있다.

```jsx
promise
  .then((res) => console.log(res)) // result
  .catch((e) => console.error(e));
```

# 로컬스토리지와 쿠키의 차이

쿠키 : 웹사이트 접속 시 브라우저에 저장되는 작은 정보 기록 파일. HTTP 는 상태가 없는 연결이기 때문에 쿠키를 통해서 사용자의 과거 이용내역을 알 수 있다.

웹 스토리지 : 로컬 스토리지, 세션 스토리지 (세션이 끝나면 데이터 사라짐)

로컬 스토리지 : 여러 탭을 띄워도 데이터가 서로 공유되며, 창이나 탭을 닫아도 데이터가 유지된다.

세션 스토리지 : 여러 탭을 띄우면 데이터가 따로 저장되며, 창이나 탭을 닫으면 데이터가 사라진다.

쿠키 vs 로컬 스토리지 : 쿠키보다 로컬 스토리지에 저장할 수 있는 용량이 훨씬 크다. 로컬 스토리지에 저장하면 HTTP로 전달되는 데이터가 줄어들어서 전체 트래픽의 양을 줄일 수 있다.

`추가`

# 옵셔널체이닝 연산자 / 단축평가에 대한 설명

옵셔널 체이닝 연산자 (?.) : 참조가 유효한지 명시적으로 검증하지 않고 내부의 속성 값을 읽는 연산자. 만약 참조가 유효하지 않다면(null, undefined) 에러를 발생시키지 않고 undefined 를 반환한다.

단축 평가 : 표현식을 평가하는 도중에 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

if 를 사용해서 false 일 때를 체크해야한다면 `||` 연산자를 사용할 수 있다.

`false || 'hello' === 'hello'`

if 를 사용해서 true 일 때를 체크해야한다면 `&&` 연산자를 사용할 수 있다.

`true && 'hello' === 'hello'`

# 원시값과 객체 비교

원시값 : number, bigInt, string, boolean, undefined, null, symbol

1. 원시값은 변하지 않는다. (만약 변수에 저장한 값이 바뀐다면 변수가 가리키는 메모리의 값이 변경되는 것이 아니라, 다른 메모리에 변경할 값을 저장하고 해당 메모리를 가리키게 한다.) 객체는 내부의 값이 변경될 수 있다.
2. 원시값을 변수에 할당하면 변수에 실제 값이 저장되지만 객체를 변수에 할당하면 변수에 참조값이 저장된다.
3. 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다. 즉 값에 의한 전달이 일어난다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 즉 참조에 의한 전달이 일어난다.

# 브라우저 렌더링 과정

파싱 : 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 구조와 의미를 부여하여 parse Tree 를 생성하는 과정

브라우저의 주소창에 url 을 입력하면 HTML, CSS, javascript 등 렌더링에 필요한 리소스들을 서버에 요청한다. 서버로부터 받은 리소스들은 파싱과정을 거쳐 parsing tree를 형성한다.

HTML은 파싱되어 DOM 트리를 형성하고, CSS은 파싱되어 CSSOM 트리를 형성한다.

DOM 트리와 CSSOM 트리는 결합하여 렌더 트리를 형성한다.

이 렌더 트리를 통해 레이아웃(위치, 크기)을 계산하고 페인팅된다.

만약 자바스크립트가 DOM API로 DOM이나 CSSOM을 변경했다면, DOM 과 CSSOM이 다시 결합하여 렌더 트리를 형성하고 리플로우(레이아웃), 리페인팅 과정을 거친다.

# DOM 이란?

HTML이 파싱되어 브라우저가 이해할 수 있도록 만든 Tree 자료구조이다.

HTML 문서의 계층적 구조와 정보를 포함한다.

# 클로저

클로저는 함수와 그 함수가 선언된 상위 스코프와의 조합이다.

중첩함수가 외부함수보다 오래 유지되는 경우, 중첩 함수는 이미 생명주기가 종료된 외부함수의 변수를 참조할 수 있는데 이 중첩함수를 클로저라고 한다.

# map과 forEach의 차이

map은 배열 내의 모든 요소에 대해 콜백함수를 실행하고 콜백함수가 반환한 값을 새 배열에 넣는다.

forEach는 배열 내의 모든 요소에 대해 콜백함수를 실행한다. 새 배열을 만들지 않는다.

# 일반 함수와 화살표 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없다. (prototype 프로퍼티 x)
2. 화살표 함수는 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.

# this

## this 의 바인딩 방식

javascript 에서 this의 바인딩 방식은 함수를 호출할 때 결정된다.

같은 함수를 선언해도 일반함수로 호출하면 this에 전역객체가 바인딩된다.

(브라우저는 Window, Node.js 는 Global, ‘use strict’ 를 사용하면 undefined)

객체의 메소드로 호출하면 this에 객체가 바인딩된다.

생성자 함수로 호출하면 this에 생성자 함수로 인해 생성된 객체가 바인딩 된다.

## 화살표 함수의 this

화살표 함수는 this가 바인딩 되지 않아 상위 스코프의 this를 사용한다.

# JS는 싱글 스레드인데 비동기가 가능한 이유는?

비동기란 ? 현재 실행중인 태스크가 완료되지 않아도 다음 태스크를 곧바로 실행하는 방식

자바스크립트는 싱글 스레드로 동작하지만 브라우저같은 런타임환경은 멀티 스레드로 동작하기 때문이다. 브라우저나 node.js 같은 런타임 환경에서 이벤트 루프와 태스크 큐를 제공한다. (nodejs도?)

태스크 큐 : 비동기함수의 콜백함수나 이벤트 핸들러가 일시적으로 보관되는 영역

이벤트 루프 : 콜스택에 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수가 있는지 반복적으로 확인한다. 콜스택에 현재 실행중인 실행 컨텍스트가 없고, 태스크 큐에 대기중인 함수가 있다면 이벤트루프는 순차적(FIFO)으로 태스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다.

# 인터프리터? 컴파일러?

컴파일러 언어는 컴파일 과정을 거쳐 머신코드로 바꾼다음 실행한다. 컴파일 시간이 있지만 실행 시간이 빠르고 그 과정에서 문법 오류나 타입오류를 감지하기 때문에 실행에서 에러를 만날 확률이 줄어든다.

인터프리터 언어는 한줄 한줄을 바이트코드로 바꾼다음 실행한다. 별도의 컴파일 과정이 없어서 바로 실행시켜볼 수 있지만 인터프리트 단계와 실행 단계가 반복적으로 일어나기 때문에 상대적으로 속도가 느리다.

자바스크립트는 별도의 컴파일 과정을 거치지 않는 인터프리터 언어이지만, 모던 자바스크립트 엔진은 컴파일러와 인터프리터의 장점을 결합하여 인터프리터 언어의 속도 문제를 해결했다.

~~자바스크립트엔진은 우선 자바스크립트 코드를 토큰으로 쪼개 AST(abstract syntax tree)라 불리는 추상 트리 구조로 만든다. 이후~~ 인터프리터에서 코드를 바이트 코드로 변환한다. 이 과정에서 최적화할 수 있는 코드를 컴파일(just in time compile)한다.
