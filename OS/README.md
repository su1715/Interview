# 프로세스와 스레드

## 프로세스

프로세스란 운영체제로부터 자원을 할당받은, 실행중인 프로그램이다.

### 프로세스 제어 블록 (Process Control Block, PCB)

운영체제가 프로세스를 관리하기위해 관련 정보를 저장하는 테이블 자료구조, 메모리 상에서 커널이 관리하는 커널 스페이스에 저장된다.
저장되는 정보는 운영체제마다 차이가 있지만 일반적으로는 다음과 같다.

- 프로세스 번호
- 프로세스 상태 (준비, 실행, 대기, 보류 등의 상태)
- 프로세스 스케줄링 정보 : 우선순위
- 프로그램 카운터 값 : 다음에 실행될 명령어 주소를 가지고 있다.
- 메모리 포인터 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 문맥 데이터 : 문맥 교환시에 CPU 레지스터 값들을 저장하는 영역
- 할당받은 자원들에 대한 목록 : 입출력 장치, 개방한 파일 등 할당받은 자원들의 정보
- 계정 정보 : CPU를 사용한 시간, 시간 제한 등에 대한 정보
- 입출력 정보 : 진행 중인 입출력 요구 등의 정보

### 프로세스는 언제 상태가 바뀌는지?

- 생성 : 사용자가 요청한 작업의 PCB가 만들어져, 준비 상태가 되기 전 잠시 거치는 상태
- 준비 : CPU를 할당받기를 기다리는 상태, CPU만 할당 받으면 바로 실행할 준비가 되어있는 상태
- 실행 : CPU를 할당받아 실행 중인 상태, 이때 CPU를 할당하는 것을 dispatch 라고 한다.
  실행상태의 CPU는 CPU 스케줄링 정책에 의해 CPU를 빼앗길 수 있는데 이 경우 준비상태로 바뀐다.
- 대기 : 프로세스가 실행되다가 입출력을 요청하거나 당장 확보할 수 없는 자원을 요청했을 때 CPU 를 양도하고 요청한 일이 완료되기를 기다리는 상태.
  요청한 일이 완료되면 다시 준비 상태가 된다.
- 보류 준비 : 준비상태에서 메모리 부족으로 당장 필요하지 않은 프로세스가 메모리 공간을 빼앗기고 디스크로 나가는 것
- 보류 대기 : 대기상태에서 메모리 부족으로 당장 필요하지 않은 프로세스가 메모리 공간을 빼앗기고 디스크로 나가는 것
- 종료 : 프로세스가 종료될 때 잠깐 거치는 상태, 이 상태의 프로세스는 할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태이다.
  운영체제가 시스템에 남겨져 있는 이 프로세스의 흔적들을 최종 정리 후 PCB를 삭제하면 프로세스가 완전히 사라지게 된다.

### 멀티 프로세스

CPU가 여러개 있어서 여러개의 프로세스를 동시에 처리할 수 있는 시스템

## 스레드

프로세스의 자원을 공유하는 스케줄링의 단위

스택과 스레드 제어 블록 (실행 중의 레지스터 값, 프로그램 카운터, 우선 순위, 스레드 상태 정보)은 스레드 각각 따로 가지지만

프로세스의 주소공간이나 열린 파일 같은 자원들은 서로 공유한다.

### 멀티 스레드

하나의 프로세스를 여러개의 스레드로 만들어 실행하는 것

멀티 스레딩을 하게 되면 하나의 프로세스 내에 여러개의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유하기 때문에

자원의 생성과 관리가 중복되는 것을 줄일 수 있다.

### 스택을 스레드마다 독립적으로 할당하는 이유

스택은 호출한 함수의 정보, 매개변수, 지역변수 등이 저장되는 곳이다.

스레드가 독립적인 실행흐름을 가지려면 독립적인 함수호출이 가능해야하므로 스택을 따로 가져아한다.

### PC Register를 스레드마다 독립적으로 할당하는 이유

스래드들이 독립적인 실행흐름을 가지려면 현재 실행하는 코드의 위치들이 서로 다를 수 있다.

따라서 PC Register에 대한 정보를 따로 저장해 문맥이 교환 됐을 때 스레드의 실행흐름을 이어갈 수 있어야한다.

### 프로세스 vs 스레드

멀티 스레딩을 하게 되면 하나의 프로세스 내에 여러개의 실행 단위들이 존재하며 작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 막을 수 있다.

또한 문맥 교환 과정에서의 부담이 적다.

`문맥 교환 더 공부하기`

### 스레드 동기화

한 프로세스 내의 스레드들은 그 프로세스의 주소공간과 자원들을 공유하기 때문에 특정 스레드가 변경시킨 내용이 다른 스레드에 영향을 미칠 수 있다.

따라서 오류를 야기할 수 있는 상호간섭, 데이터 파괴를 방지하기 위해 동기화가 요구된다.

`동기화 내용 추가하기`

<hr/>

# 스케줄러

스케줄러에는 단기스케줄러, 중기스케줄러, 장기스케줄러가 있다.

단기스케줄러는 CPU 스케줄러로, 준비 큐에 있는 프로세스 중 하나를 선택헤 CPU를 할당한다.

중기스케줄러는 메모리 공간이 확보되었을 때 보류상태에 있는 프로세스들 중 어떤 프로세스에게 메모리를 할당하여 준비 혹은 대기상태로 만들 것인지 정한다.

장기스케줄러는 프로세스가 되고자 하는 프로그램들 중 어떤 프로그램을 프로세스로 만들지 정한다.

# CPU 스케줄러 (단기 스케줄러)

준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할 것인지 정하는 스케줄러

아래와 같은 스케줄링 방식들이 사용될 수 있다.

### FCFS (FIFO)

먼저 준비 큐에 들어온 프로세스가 먼저 CPU를 할당받는 방식

비선점형

### SJF (SPN)

준비 큐에 있는 프로세스 중 가장 작업시간이 적은 프로세스에 CPU를 할당하는 방식

비선점형

- 기아상태에 빠질 수 있다.

### SRTF

준비 큐에 있는 프로세스 중 가장 작업시간이 적은 프로세스에 CPU를 할당하는 방식

선점형 : 새로운 프로세스가 들어올 때마다 계산한다.

- 기아상태에 빠질 수 있다.

### Priority

우선순위가 높은 프로세스를 먼저 CPU에 할당한다.

선점형과 비선점형 모두 가능하다.

### Round Robin

# 프로세스 동기화

# 메모리

# 캐시
