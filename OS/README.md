# 프로세스와 스레드

## 프로세스

프로세스란 운영체제로부터 자원을 할당받은, 실행중인 프로그램이다.

### 프로세스 제어 블록 (Process Control Block, PCB)

운영체제가 프로세스를 관리하기위해 관련 정보를 저장하는 테이블 자료구조, 메모리 상에서 커널이 관리하는 커널 스페이스에 저장된다.
저장되는 정보는 운영체제마다 차이가 있지만 일반적으로는 다음과 같다.

- 프로세스 번호
- 프로세스 상태 (준비, 실행, 대기, 보류 등의 상태)
- 프로세스 스케줄링 정보 : 우선순위
- 프로그램 카운터 값 : 다음에 실행될 명령어 주소를 가지고 있다.
- 메모리 포인터 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 문맥 데이터 : 문맥 교환시에 CPU 레지스터 값들을 저장하는 영역
- 할당받은 자원들에 대한 목록 : 입출력 장치, 개방한 파일 등 할당받은 자원들의 정보
- 계정 정보 : CPU를 사용한 시간, 시간 제한 등에 대한 정보
- 입출력 정보 : 진행 중인 입출력 요구 등의 정보

### 프로세스는 언제 상태가 바뀌는지?

- 생성 : 사용자가 요청한 작업의 PCB가 만들어져, 준비 상태가 되기 전 잠시 거치는 상태
- 준비 : CPU를 할당받기를 기다리는 상태, CPU만 할당 받으면 바로 실행할 준비가 되어있는 상태
- 실행 : CPU를 할당받아 실행 중인 상태, 이때 CPU를 할당하는 것을 dispatch 라고 한다.
  실행상태의 CPU는 CPU 스케줄링 정책에 의해 CPU를 빼앗길 수 있는데 이 경우 준비상태로 바뀐다.
- 대기 : 프로세스가 실행되다가 입출력을 요청하거나 당장 확보할 수 없는 자원을 요청했을 때 CPU 를 양도하고 요청한 일이 완료되기를 기다리는 상태.
  요청한 일이 완료되면 다시 준비 상태가 된다.
- 보류 준비 : 준비상태에서 메모리 부족으로 당장 필요하지 않은 프로세스가 메모리 공간을 빼앗기고 디스크로 나가는 것
- 보류 대기 : 대기상태에서 메모리 부족으로 당장 필요하지 않은 프로세스가 메모리 공간을 빼앗기고 디스크로 나가는 것
- 종료 : 프로세스가 종료될 때 잠깐 거치는 상태, 이 상태의 프로세스는 할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태이다.
  운영체제가 시스템에 남겨져 있는 이 프로세스의 흔적들을 최종 정리 후 PCB를 삭제하면 프로세스가 완전히 사라지게 된다.

### 멀티 프로세스

CPU가 여러개 있어서 여러개의 프로세스를 동시에 처리할 수 있는 시스템

## 스레드

프로세스의 자원을 공유하는 스케줄링의 단위

스택과 스레드 제어 블록 (실행 중의 레지스터 값, 프로그램 카운터, 우선 순위, 스레드 상태 정보)은 스레드 각각 따로 가지지만

프로세스의 주소공간이나 열린 파일 같은 자원들은 서로 공유한다.

### 멀티 스레드

하나의 프로세스를 여러개의 스레드로 만들어 실행하는 것

멀티 스레딩을 하게 되면 하나의 프로세스 내에 여러개의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유하기 때문에

자원의 생성과 관리가 중복되는 것을 줄일 수 있다.

### 스택을 스레드마다 독립적으로 할당하는 이유

스택은 호출한 함수의 정보, 매개변수, 지역변수 등이 저장되는 곳이다.

스레드가 독립적인 실행흐름을 가지려면 독립적인 함수호출이 가능해야하므로 스택을 따로 가져아한다.

### PC Register를 스레드마다 독립적으로 할당하는 이유

스래드들이 독립적인 실행흐름을 가지려면 현재 실행하는 코드의 위치들이 서로 다를 수 있다.

따라서 PC Register에 대한 정보를 따로 저장해 문맥이 교환 됐을 때 스레드의 실행흐름을 이어갈 수 있어야한다.

### 프로세스 vs 스레드

멀티 스레딩을 하게 되면 하나의 프로세스 내에 여러개의 실행 단위들이 존재하며 작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 막을 수 있다.

또한 문맥 교환 과정에서의 부담이 적다.

`문맥 교환 더 공부하기`

### 스레드 동기화

한 프로세스 내의 스레드들은 그 프로세스의 주소공간과 자원들을 공유하기 때문에 특정 스레드가 변경시킨 내용이 다른 스레드에 영향을 미칠 수 있다.

따라서 오류를 야기할 수 있는 상호간섭, 데이터 파괴를 방지하기 위해 동기화가 요구된다.

`동기화 내용 추가하기`

<hr/>

# 스케줄러

스케줄러에는 단기스케줄러, 중기스케줄러, 장기스케줄러가 있다.

단기스케줄러는 CPU 스케줄러로, 준비 큐에 있는 프로세스 중 하나를 선택헤 CPU를 할당한다.

중기스케줄러는 메모리 공간이 확보되었을 때 보류상태에 있는 프로세스들 중 어떤 프로세스에게 메모리를 할당하여 준비 혹은 대기상태로 만들 것인지 정한다.

장기스케줄러는 프로세스가 되고자 하는 프로그램들 중 어떤 프로그램을 프로세스로 만들지 정한다.

## CPU 스케줄러 (단기 스케줄러)

준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할 것인지 정하는 스케줄러

아래와 같은 스케줄링 방식들이 사용될 수 있다.

### FCFS (FIFO)

먼저 준비 큐에 들어온 프로세스가 먼저 CPU를 할당받는 방식

비선점형

### SJF (SPN)

준비 큐에 있는 프로세스 중 가장 작업시간이 적은 프로세스에 CPU를 할당하는 방식

비선점형

- 기아상태에 빠질 수 있다.

### SRTF

준비 큐에 있는 프로세스 중 가장 작업시간이 적은 프로세스에 CPU를 할당하는 방식

선점형 : 새로운 프로세스가 들어올 때마다 계산한다.

- 기아상태에 빠질 수 있다.

### Priority

우선순위가 높은 프로세스를 먼저 CPU에 할당한다.

선점형과 비선점형 모두 가능하다.

- 기아상태에 빠질 수 있다.

- aging : wait time 이 길어지면 우선순위를 높이는 방식으로 기아상태를 어느정도 해결할 수 있다.

### Round Robin

준비큐의 프로세스에 일정한 시간만큼 CPU를 할당하는 방식

할당된 시간이 지나면 프로세스는 선점당하고 준비 큐의 가장 뒤로 들어간다.

- 한 프로세스에 할당되는 시간이 t, 준비큐의 프로세스가 n 개라고 한다면, 준비큐의 어떤 프로세스도 t\*(n - 1) 시간을 초과해서 기다리지 않는다.

- 따라서 기아상태에 빠지지 않는다.

- 응답시간이 빨라진다.

- 시간할당량이 너무 커지면 **FCFS** 와 같아지고, 시간할당량이 너무 작아지면 문맥교환에서 오버헤드가 커진다. 따라서 적당한 시간을 설정하는 것이 중요하다.

`적당한 할당 시간량 어떻게?`

`스케줄링 기법 더 적기`

<hr/>

# 프로세스 동기화

<hr/>

# 메모리

## 가상 메모리

프로세스가 CPU를 할당받기 위해서는 메모리에 적재되어야한다.

하지만 메모리의 크기에는 한계가 있기 때문에 프로세스 전체의 크기가 메모리보다 큰 경우가 발생할 수 있다.

프로세스 크기가 메모리보다 작다고 해도 프로세스 전체를 메모리에 적재하면 메모리에 올라올 수 있는 프로세스의 수가 한정된다.

따라서 프로세스의 일부만 메모리에 적재하여 다중 프로그래밍 정도를 늘려, 사용자가 여러 프로그램을 동시에 실행하는 것처럼 느끼게 할 수 있다.

같은 크기로 나누면 페이징 기법이고 다른 크기로 나누면 세그먼트 기법이다.

### 주소의 매핑

가상 메모리에서 중요한 것은 주소의 매핑이다.

가상 메모리를 사용하면 프로그램에서 참조하는 주소가 실제 메모리에 있는 주소와 달라서, 메모리상의 주소로 변환이 필요하다.

만약 주소의 지정이 컴파일 시에 이루어진다면 프로그램이 참조하는 주소가 바로 실주소이기 때문에, 프로그램은 항상 메모리의 지정된 곳으로만 적재되어야한다.

가상 메모리 기법에서는 여러 프로세스의 일부를 메모리에 적재하므로 컴파일에서 주소의 지정이 이뤄져서는 안된다.

따라서 실행중인 프로그램 내에서 참조하는 주소는 가상주소를 사용하고, 주소의 매핑을 통해 물리주소를 찾아간다.

가상주소가 <3, 5> 라면 3번째 페이지(세그멘테이션)의 5번째 offset을 가리킨다는 뜻이다.

물리주소를 찾으려면 페이지(세그멘테이션)의 크기 \* 3 + 5 를 하면 된다.

## 페이징 기법

페이징을 위해서는 모든 프로세스들이 같은 크기의 조각들로 나뉘어야하는데 이떄 한 조각을 페이지라고 부른다.

메모리 역시 프레임이라는 페이지와 같은 크기로 나누어져 있으며 일련 번호가 있다.

한 프로세스의 전체 페이지는 디스크에 저장되고, 일부 페이지만 메모리에 적재되는데, 프로세스의 실행이 진행되는 과정에서 디스크와 메모리를 오가며 교체되는 단위가 페이지이며, 이것은 곧 사상의 단위가 된다.

운영체제는 가상주소를 실주소로 변환하기 위해 `프로세스당 하나의 페이지 테이블`을 만들어 두어야 하는데, 이것을 페이지 사상 테이블이라 부른다.

이 테이블의 크기는 해당 프로세스의 페이지 개수에 비례한다.

매핑을 위한 정보는 페이지당 하나씩 있어야 하므로 k 개의 페이지를 가지는 프로세스의 페이지 테이블을 k개의 엔트리로 구성된다.

한 프로세스에서 나뉘는 페이지들은 일련번호를 가지는데 페이지 테이블은 이 번호 순서대로 엔트리를 배치시킨다.

엔트리에 들어있는 정보 : 존재비트 (존재시 1), 존재시 적재되어 있는 프레임 번호, 존재하지 않을 시 페이지가 저장되어있는 디스크의 주소를 나타내는 필드

실행 시 참조되는 가상주소는 페이지 번호(p)와 페이지 내에서의 위치(d)로 표시된다.

페이지 테이블은 메모리의 커널 영역에 보관되며, 실행 중인 프로세스의 페이지 테이블 시작주소는 페이지 테이블 기준 레지스터에 들어있다.

먼저 기준 레지스터의 값에 p를 더해서 페이지 테이블에서 페이지 p의 사상 정보를 갖고 있는 엔트리를 찾은 후, 존재 비트를 확인한다.

존재 비트가 1일 경우 p가 적재되어 있는 프레임 번호를 알 수 있으므로, 이 번호 값에 페이지 크기를 곱하면 메모리에서 이 프레임의 시작주소를 얻을 수 있다.

프레임의 시작주소에 페이지 내의 위치 (d)를 더하면 프레임 내에서 접근해야 할 워드의 주소 즉, 실주소로 접근하게 되는 것이다.

존재 비트가 0인 경우 접근하고자 하는 페이지가 메모리에 없음을 의미하므로 먼저 디스크 주소로부터 이 페이지를 매모리에 적재한다.

그 다음 이 엔트리의 존재 비트를 1로 바꾸고, 적재된 프레임 번호를 기입한 후 매핑을 진행하면 실 주소를 얻을 수 있다.

### TLB의 사용

## 세그멘테이션 기법

# 캐시
