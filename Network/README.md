# LAN vs WAN

LAN : 특정 지역이나 건물 내부를 범위로 하는 네트워크. WAN 보다 범위가 좁고 속도가 빠르며 오류가 발생할 확률이 낮다.

WAN : ISP(인터넷 서비스 제공자)에서 제공하는 서비스를 이용하여 구축한 네트워크. LAN 보다 범위가 넓고 속도가 느리며 오류가 발생할 확률이 높다.

<hr/>

# OSI 7계층

## 7계층으로 나누는 이유

계층을 나눔으로써 각 계층에서 맡은 기능을 모듈화 시킬 수 있다. 각 계층을 업그레이드 시키거나 어디서 문제가 발생했는지 확인하는 것이 쉬워지기 때문에 유연성과 확장성이 높은 시스템을 구축할 수 있게한다.

## layers

### 응용 계층 (Application Layer)

이메일 & 파일 전송, 웹 사이트 조회 등 애플리케이션에 대한 서비스를 제공한다.

### 표현 계층 (Representation Layer)

송, 수신자가 공통으로 이해할 수 있도록 정보의 데이터 표현방식을 바꾸는 기능을 담당한다.

### 세션 계층 (Session Layer)

세션 계층은 네트워크 대화 제어기로 통신 시스템 간에 상호 대화를 설정하고 동기화한다.

### 전송 계층 (Transport Layer)

Port 를 사용하여 응용프로그램 간 송수신을 담당한다.

**프로세스 간의 논리적 통신을 제공한다.**

### 네트워크 계층 (Network Layer)

**호스트 간의 논리적 통신을 제공한다.**

IP를 주소로 사용하여 호스트간 전송을 담당한다. 네트워크 간의 통신을 가능하게 한다.

IP 헤더를 붙인다. IP 헤더에는 출발지 IP 주소와 도착지 IP 주소가 포함된다.

라우터 : 목적지로 가기 위해 다른 네트워크로의 경로를 정해주는 장비. IP주소를 통해 목적지를 지정한다.

IP : 어떤 네트워크의 어떤 컴퓨터인지를 구분할 수 있게 하는 논리적 주소

IP 주소에는 공인 IP와 사설 IP 가 존재한다. IPv4는 주소의 수가 고갈되고 있기 때문에 인터넷에 직접 연결되는 컴퓨터나 라우터에는 공인 IP를 할당하고 회사나 가정의 랜에 있는 컴퓨터에는 사설 IP 주소를 할당하는 정책을 사용한다.

공인 IP는 ISP(인터넷 서비스 제공자) 가 제공한다.

### 데이터 링크 계층 (Data Link Layer)

네트워크 기기 간의 데이터 전송 및 물리 주소를 결정한다.

이더넷 헤더와 트레일러를 붙인다.

이더넷 헤더는 목적지의 MAC 주소, 출발지의 MAC 주소로 이루어져있다.

### 물리 계층 (Physical Layer)

시스템 간의 물리적인 연결을 담당하고 전기 신호를 변환 및 제어한다.

데이터를 송신할 때는 0과 1의 집합을 전기적 신호로 바꾸고 (랜카드)

데이터를 수신할 때는 전기적 신호를 0과 1의 집합으로 바꾼다.

<hr/>

# TCP / IP 4계층

응용계층, 전송계층, 인터넷 계층, 네트워크 접속 계층

## IP

호스트간의 논리적 통신을 제공. 지정한 IP 주소에 데이터를 전달하는 프로토콜이다.

패킷이라는 통신 단위로 데이터를 저장하며 패킷에는 출발지 IP, 목적지 IP 등의 정보가 있다.

best-effort 방식이기 때문에 비연결성 비신뢰성 등의 문제가 있다.

### IP 프로토콜의 한계

- 비 연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

- 비 신뢰성 : 중간에 패킷이 손실될 수도 있고, 순서가 바뀔 수도 있다.

- 호스트를 구분할 뿐 프로세스를 구분할 수 없다.

## UDP

간단한 오류를 체크하는 기능(체크섬)과 다중화/역다중화 기능을 제외하고는 IP에 아무것도 추가하지 않는다.

그렇다고해서 항상 TCP 가 좋은가? 하고 물으면 대답은 "아니오" 이다.

TCP 연결은 목적 호스트에서 수신 여부를 응답할때 까지 재전송을 계속한다. 하지만 실시간 애플리케이션은 최소 전송을 요구하며, 조금의 데이터 손실은 허용할 수 있으므로 TCP와 맞지 않는다.

또한 UDP 는 TCP와는 달리 연결 설정이 없다. 따라서 연결을 설정하기 위한 지연이 없다. DNS는 연결 지연이 없는 UDP 위에서 동작한다.

## TCP

- 연결지향 : TCP 3 way handshake (가상 연결)

- 신뢰성 : 데이터 전달 보증, 순서 보장

### TCP 3 way handshake

1. client --------- SYN ---------> server

2. client <------ SYN + ACK ------ server

3. client --- ACK + (request) ---> server

### 소켓과 포트

- 소켓 : 프로세스가 데이터를 주고받기 위해 여는 창구

- 포트 : 프로세스를 식별하기 위해 호스트 내부적으로 할당받는 값

### 다중화 / 역다중화

역다중화 : 트랜스포트 계층의 세그먼트 데이터를 올바른 소켓으로 전달하는 것

다중화 : 소켓으로부터 데이터를 전달받아 캡슐화 하고 네트워크 계층으로 내려보내는 것

- UDP 계층의 역다중화 : 소켓을 식별하기 위해 목적지의 IP와 포트번호를 사용한다.

- TCP 계층의 역다중화 : 소켓을 식별하기 위해 출발지 IP, 포트번호, 도착지 IP, 포트번호를 모두 사용한다.

### 흐름제어 / 오류제어 / 혼잡제어

- 흐름 제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법

  수신측의 패킷 버퍼 크기보다 많은 수의 패킷이 한번에 들어오면 패킷이 손실 된다. 이를 방지하기 위하여 흐름 제어기법을 사용한다.

  1. stop-and-wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 기법

  2. sliding window : 수신 측에서 설정한 윈도우 크기만큼 송신측에서 패킷에 대한 응답없이 전송하게 하는 기법, 데이터 흐름을 동적으로 조절할 수 있다.

- 오류 제어 (ARQ, Automatic Repeat Request) : 데이터가 손상되거나 손실되었을 경우 재전송을 통해 오류를 복구하는 기법

  1. stop-and-wait ARQ : 송신측에서 하나의 데이터를 송신하고 수신측에서 에러 판단에 대한 응답(ACK or NAK)을 보내는 방식이다. NAK을 받거나 타임아웃이 되면 데이터를 재전송한다.

  2. Go-Back-n ARQ (슬라이딩 윈도우) : 전송된 데이터가 손상되거나 분실되거나 Timeout이 발생한 경우 확인된 마지막 프레임 이후로 모든 데이터를 재전송한다.

  3. SR (Select-Reject) ARQ : 손상,손실된 데이터만을 재전송하는 기법. 확인된 마지막 데이터 이후로 모든 데이터를 재전송하는 GBn의 단점을 보완한다. 순차적이지 않은 데이터를 재정렬하기 위한 버퍼가 필요하다.

- 혼잡 제어 : 네트워크 내에 패킷의 수가 과도하게 증가하는 것을 막기위해 송신 측에서 데이터를 보내는 속도를 조절하는 기법

  1. AIMD (Additive Increase, Multicative Decrease) 합증가 곱감소

  - 처음에는 패킷을 하나 보내는 것으로 시작하여 전송한 패킷이 문제없이 도착한다면 window size 를 하나씩 늘리는 기법

  - 패킷 전송이 실패하면 window size를 절반으로 줄인다.

  - 초기에 높은 대역폭을 사용하지 못하고, 혼잡해지고 나서야 대역폭을 줄인다는 단점이 있다.

  2. Slow Start

  - 처음에는 패킷을 하나 보내는 것으로 시작하지만 ACK 패킷 마다 window size 를 1씩 늘려 한 주기가 지나면 두배로 증가한다.

  - 즉 지수함수 꼴로 window size가 증가하기 때문에 윈도우 크기가 더 빠르게 증가한다.

  - 혼잡이 감지되면 window size를 1로 줄인다.

  - 한번 혼잡이 발생한 이후로는 네트워크 수용량을 예상할 수 있으므로 혼잡이 발생한 window size의 절반까지는 지수함수 꼴로 window size를 증가시키고, 그 이후로는 1씩 증가시킨다.

  3. Fast Retransmit (빠른 재전송)

  - 패킷을 보냈는데 수신측이 timeout 전에 특정 패킷을 보내달라는 요청을 3번 연속하는 경우, timeout이 나지 않더라도 특정 패킷을 재전송하고 혼잡한 상황이라고 판단해 윈도우 크기를 줄인다.

  4. Fast Recovery (빠른 회복)

  - 혼잡한 상태가 되면 윈도우 크기를 1이 아니라 반으로 줄이고 선형증가 시킨다. (1씩 증가)

<hr/>

## HTTP

웹에서 서버와 클라이언트가 메세지를 교환하는 방식을 정의하는 프로토콜

상태가 없는 (stateless) 연결

HTTP/2 까지는 전송 프로토콜로 TCP를 사용한다.

지속연결과 비지속연결 모두 가능하며 지속연결을 기본으로 사용한다.

지속연결 : 일정한 시간 내에 일어나는 여러 요청들에 대한 응답을 하나의 TCP 연결로 보내는 것.

비지속연결 : 모든 요청에 대한 응답을 다른 TCP 연결로 보내는 것. TCP 버퍼와 TCP 변수를 매번 새로 설정해야하기 때문에 시간이 오래걸리고 오버헤드가 크다.

### HTTP 메소드 종류와 역할

- GET : 리소스 조회

- POST : 데이터 처리 요청

- PUT : 리소스를 대체, 해당 리소스가 없으면 생성

- PATCH : 리소스를 일부만 변경

- DELETE : 리소스 삭제

- HEAD : GET 과 비슷하지만 body 부분을 제외하고, 응답 상태와 헤더만 반환 (디버깅에 쓰임)

### HTTP 버전별 차이 (/1.0 /1.1 /2 /3)

- 1.0

  Method : GET, HEAD, POST

  Connection : 응답 직후 종료

  비지속 연결을 기본값으로 사용하여 모든 응답에 새로운 TCP 연결이 생성된다.

  Connection 헤더에 keep-alive 를 넣어 지속연결을 사용할 수 있다.

- 1.1

  Method: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS

  Connection : long-lived

  지속 연결을 기본으로 사용하여 연속되는 요청에 대한 응답으로 같은 TCP 연결을 사용할 수 있다.

  pipelining : 클라이언트가 여러 요청을 보낼 때 응답을 기다리지 않고 요청을 보낼 수 있다.

  mutiple connections : TCP 다중연결을 통해 동시에 요청을 보낼 수 있다.

- 2

  1.1을 기반으로 성능향상이 이뤄졌다.

  같은 TCP 연결에서 다중 요청과 응답이 가능하다. 응답은 순서와 상관없이 주고받는다.

  server push : 클라이언트가 요청하지 않은 리소스를 서버가 사전에 전송할 수 있다. 요청을 보낼 것이라고 예측되는 리소스를 미리 전송

### 쿠키와 세션

HTTP는 상태를 저장하지 않는 프로토콜이다. 이로 인해서 서버가 한번에 많은 요청을 받을 수 있다는 장점이 있지만, 서버에서 사용자를 식별할 필요가 있을 때가 있다. 그럴 때 사용하는 것이 쿠키와 세션이다.

- 쿠키
  사용자에 대한 정보를 브라우저에 저장하게 하고, 사용자가 웹사이트에 접속할때 쿠키를 같이 전송하게 해서 사용자를 식별하고 사용자 맞춤 서비스를 제공할 수 있다.

- 세션
  쿠키에 저장된 세션 아이디를 기반으로 사용자를 구별한다. 하지만 쿠키와 달리 사용자 정보를 서버에 저장한다. 일정한 기간동안이나 브라우저를 닫을 때 까지 세션을 유지한다. 사용자 정보를 서버에 저장하기 때문에 쿠키만 사용하는 것에 비해 보안이 우수하지만, 서버에 저장해야하기 때문에 서버의 부담이 크다는 단점이 있다.

### HTTPS

HTTP 는 암호화되지 않았기 때문에 제 3자가 정보를 조회할 경우 중요한 정보가 탈취될 수 있다.

HTTPS 는 이러한 문제를 해결하기 위해 등장한, HTTP에 데이터 암호화를 추가한 프로토콜이다.

연결 과정에서 서버는 CA로부터 발급 받은 인증서를 클라이언트에게 전달한다.

클라이언트는 인증서의 유효성을 확인하고 서버의 공개키를 획득한다.

서버의 공개키를 통해 암호화 세션키를 만들어 서버에게 전달한다.

서버는 비밀키를 통해 세션키를 획득한다.

이후 연결이 유지되는 동안 세션키를 통해서 데이터를 암호화해 주고받는다.

대칭키(세션키)만 사용하지 않는 이유 : 세션키를 교환하는 과정에서 탈취당할 수 있기 때문에

비대칭키만 사용하지 않는 이유 : 연산 시간이 오래걸리기 때문

<hr/>

## DNS

www.naver.com 같은 hostname 은 사람이 읽기 쉽게 만든 것이고 사실은 hostname과 매핑되는 IP 주소가 있다.

호스트 네임에 대응하는 IP 주소를 알기 위해서 DNS(Domain Name System)을 사용한다.

### 단일 DNS 서버

DNS 서버는 호스트네임과 IP 주소를 매핑하는 레코드를 가지고 있는데, 이것을 하나의 서버로 관리할 경우 문제가 생긴다.

1. 트래픽 양 : 단일 서버가 모든 DNS 서비스를 처리해야한다.

2. 서버 고장 : 만약 이 서버가 고장나면 전체 인터넷이 작동하지 않는다.

3. 먼거리의 중앙 집중 데이터베이스 : 모든 요청이 하나의 DNS에 가까울 수는 없기 때문에 지연이 발생한다.

4. 유지관리 : 하나의 데이터베이스에서 모든 레코드를 관리하면 데이터베이스가 너무 거대해진다. 이는 유지관리를 어렵게 만든다.

따라서 DNS 는 분산되도록 설계되었다.

### 분산 계층 DNS 서버

분산 계층 DNS 에는 세 유형의 DNS 서버가 있다.

루트 DNS 서버, TLD DNS 서버, 책임 DNS 서버이다.

클라이언트가 (ISP 가 제공하거나 기관이 구축한)로컬 DNS 서버에게 DNS 요청을 하면,

로컬 DNS 서버는 루트 DNS 서버에게 요청을 보낸다. 루트 DNS 서버는 해당 hostname(.com, .org 등)을 관리하는 TLD DNS 서버 리스트를 보낸다.

로컬 DNS 서버는 TLD DNS 서버에게 요청을 보낸다. TLD DNS 서버는 해당 hostname을 관리하는 책임 DNS 서버의 IP 주소를 응답한다.

로컬 DNS 서버가 책임 DNS 서버에게 요청을 보낸다. 책임 DNS 서버는 해당 hostname에 대한 IP 주소를 응답한다.

로컬 DNS 서버는 IP 주소를 클라이언트에게 응답한다.

이렇게 DNS를 통해 IP 주소를 알기 위해서 8번의 메세지를 주고받아야한다.

### DNS 캐싱

위에서 살펴본 바에 따르면 DNS로 인해 너무 많은 메세지를 주고받는다. 이 때문에 네트워크 전체의 트래픽이 늘어나고, DNS 속도 또한 느리다.

따라서 DNS 캐싱을 통해 이 문제를 해결한다. 로컬 DNS 서버에 요청에 대한 응답을 저장하여 같은 요청이 들어왔을때 그대로 응답하는 것이다.

하지만 hostname과 IP 주소의 매핑은 영구적이지 않기 때문에 일정 기간이 지나면 폐기한다.

또한 로컬 DNS 서버는 TLD 서버의 IP를 저장하여 루트 DNS 서버를 우회할 수 있다.

<hr/>

# 기타

## 로드 밸런싱

서버에 가해지는 부하를 분산해주는 기술

scale - up : 서버 자체의 성능을 향상 시키는 것

scale - out : 서버를 증설하는 것

scale - out 을 한다면 트래픽을 균등하게 분배해주는 로드 밸런싱이 필수이다.

## REST API

## REAT ful

## CORS

## 웹서버와 WAS의 차이

## ARP, DHCP 프로토콜

- ARP

  IP 주소를 MAC 주소로 바꾸는 프로토콜

- DHCP

  유무선 IP 환경에서 단말의 IP 주소, 서브넷 마스크(Subnet Mask), 디폴트 게이트웨이(Default Gateway) , IP 주소, DNS 서버 IP 주소, 임대기간(Lease Time) 등의 다양한 네트워크 정보를 DHCP 서버가 PC와 같은 이용자 단말에 자동으로 할당해 주는 프로토콜

## www.naver.com 에 접속할 때 일어나는 일

- DNS : Local DNS 서버에 hostname 과 매핑되는 IP 주소를 요청한다. 만약 캐싱되어있다면 바로 IP 주소를 받을 것이고, 그렇지 않다면 계층화된 DNS 서버 (루트, TLD, 책임)를 거쳐서 IP 주소를 알아낼 것이다.

- HTTP : 리소스의 url 으로 HTTP 요청 메세지를 만든다. 소켓을 통해 전송계층으로 내려보낸다.

- TCP : HTTP가 버전 3이 아니라면 TCP 연결을 사용할 것이다. TCP 연결을 사용하기 위해서 3 way handshake를 해야한다. 만약 HTTPS 라면 SSL handshake 가 추가된다.

- IP : IP 주소를 토대로 서버 호스트에게 데이터를 전달한다.

HTTP 요청을 전달받은 서버는 url에 해당하는 리소스를 찾아 HTTP 응답을 만들어 전송한다. 네이버 메인페이지에는 HTML, CSS, JavaScript 파일, 이미지 등의 많은 리소스가 필요할 것이다. 이때 TCP 전송 과정에서 파이프라이닝과 멀티 연결이 사용될 수 있다.

클라이언트는 HTTP 응답의 Body로 리소스를 받는다.

## 유니캐스트, 멀티캐스트, 브로드캐스트

- 유니캐스트

  MAC 주소를 사용하는 일대일 통신. 자신의 MAC 주소와 동일하지 않으면 무시하기 때문에 CPU 성능을 저하시키지 않음

- 브로드캐스트

  같은 네트워크 상의 모든 장비들에게 보내는 통신. 메세지를 받는 과정에서 CPU 를 사용하기 때문에 과도한 사용은 CPU 성능을 저하시킬 수 있음.

  주로 상대의 IP는 알지만 MAC 주소를 모를 경우에 사용

- 멀티캐스트

  특정 그룹에게만 보내는 통신. 라우터가 멀티캐스트를 지원해야한다.
