# LAN vs WAN

LAN : 특정 지역이나 건물 내부를 범위로 하는 네트워크. WAN 보다 범위가 좁고 속도가 빠르며 오류가 발생할 확률이 낮다.

WAN : ISP(인터넷 서비스 제공자)에서 제공하는 서비스를 이용하여 구축한 네트워크. LAN 보다 범위가 넓고 속도가 느리며 오류가 발생할 확률이 높다.

# OSI 7계층

## 7계층으로 나누는 이유

계층을 나눔으로써 각 계층에서 맡은 기능을 모듈화 시킬 수 있다. 각 계층을 업그레이드 시키거나 어디서 문제가 발생했는지 확인하는 것이 쉬워지기 때문에 유연성과 확장성이 높은 시스템을 구축할 수 있게한다.

## layers

### 응용 계층 (Application Layer)

이메일 & 파일 전송, 웹 사이트 조회 등 애플리케이션에 대한 서비스를 제공한다.

### 표현 계층 (Representation Layer)

송, 수신자가 공통으로 이해할 수 있도록 정보의 데이터 표현방식을 바꾸는 기능을 담당한다.

### 세션 계층 (Session Layer)

세션 계층은 네트워크 대화 제어기로 통신 시스템 간에 상호 대화를 설정하고 동기화한다.

### 전송 계층 (Transport Layer)

Port 를 사용하여 응용프로그램 간 송수신을 담당한다.

### 네트워크 계층 (Network Layer)

IP를 주소로 사용하여 호스트간 전송을 담당한다. 네트워크 간의 통신을 가능하게 한다.

IP 헤더를 붙인다. IP 헤더에는 출발지 IP 주소와 도착지 IP 주소가 포함된다.

라우터 : 목적지로 가기 위해 다른 네트워크로의 경로를 정해주는 장비. IP주소를 통해 목적지를 지정한다.

IP : 어떤 네트워크의 어떤 컴퓨터인지를 구분할 수 있게 하는 논리적 주소

IP 주소에는 공인 IP와 사설 IP 가 존재한다. IPv4는 주소의 수가 고갈되고 있기 때문에 인터넷에 직접 연결되는 컴퓨터나 라우터에는 공인 IP를 할당하고 회사나 가정의 랜에 있는 컴퓨터에는 사설 IP 주소를 할당하는 정책을 사용한다.

공인 IP는 ISP(인터넷 서비스 제공자) 가 제공한다.

### 데이터 링크 계층 (Data Link Layer)

네트워크 기기 간의 데이터 전송 및 물리 주소를 결정한다.

이더넷 헤더와 트레일러를 붙인다.

이더넷 헤더는 목적지의 MAC 주소, 출발지의 MAC 주소로 이루어져있다.

### 물리 계층 (Physical Layer)

시스템 간의 물리적인 연결을 담당하고 전기 신호를 변환 및 제어한다.

데이터를 송신할 때는 0과 1의 집합을 전기적 신호로 바꾸고 (랜카드)

데이터를 수신할 때는 전기적 신호를 0과 1의 집합으로 바꾼다.

# TCP / IP 4계층

응용계층, 전송계층, 인터넷 계층, 네트워크 접속 계층

# DNS

www.naver.com 같은 hostname 은 사람이 읽기 쉽게 만든 것이고 사실은 hostname과 매핑되는 IP 주소가 있다.

호스트 네임에 대응하는 IP 주소를 알기 위해서 DNS(Domain Name System)을 사용한다.

## 단일 DNS 서버

DNS 서버는 호스트네임과 IP 주소를 매핑하는 레코드를 가지고 있는데, 이것을 하나의 서버로 관리할 경우 문제가 생긴다.

1. 트래픽 양 : 단일 서버가 모든 DNS 서비스를 처리해야한다.

2. 서버 고장 : 만약 이 서버가 고장나면 전체 인터넷이 작동하지 않는다.

3. 먼거리의 중앙 집중 데이터베이스 : 모든 요청이 하나의 DNS에 가까울 수는 없기 때문에 지연이 발생한다.

4. 유지관리 : 하나의 데이터베이스에서 모든 레코드를 관리하면 데이터베이스가 너무 거대해진다. 이는 유지관리를 어렵게 만든다.

따라서 DNS 는 분산되도록 설계되었다.

## 분산 계층 DNS 서버

분산 계층 DNS 에는 세 유형의 DNS 서버가 있다.

루트 DNS 서버, TLD DNS 서버, 책임 DNS 서버이다.

클라이언트가 (ISP 가 제공하거나 기관이 구축한)로컬 DNS 서버에게 DNS 요청을 하면,

로컬 DNS 서버는 루트 DNS 서버에게 요청을 보낸다. 루트 DNS 서버는 해당 hostname(.com, .org 등)을 관리하는 TLD DNS 서버 리스트를 보낸다.

로컬 DNS 서버는 TLD DNS 서버에게 요청을 보낸다. TLD DNS 서버는 해당 hostname을 관리하는 책임 DNS 서버의 IP 주소를 응답한다.

로컬 DNS 서버가 책임 DNS 서버에게 요청을 보낸다. 책임 DNS 서버는 해당 hostname에 대한 IP 주소를 응답한다.

로컬 DNS 서버는 IP 주소를 클라이언트에게 응답한다.

이렇게 DNS를 통해 IP 주소를 알기 위해서 8번의 메세지를 주고받아야한다.

## DNS 캐싱

위에서 살펴본 바에 따르면 DNS로 인해 너무 많은 메세지를 주고받는다. 이 때문에 네트워크 전체의 트래픽이 늘어나고, DNS 속도 또한 느리다.

따라서 DNS 캐싱을 통해 이 문제를 해결한다. 로컬 DNS 서버에 요청에 대한 응답을 저장하여 같은 요청이 들어왔을때 그대로 응답하는 것이다.

하지만 hostname과 IP 주소의 매핑은 영구적이지 않기 때문에 일정 기간이 지나면 폐기한다.

또한 로컬 DNS 서버는 TLD 서버의 IP를 저장하여 루트 DNS 서버를 우회할 수 있다.

## www.naver.com 에 접속할 때 일어나는 일

# TCP / IP

## 유니캐스트, 멀티캐스트, 브로드캐스트

- 유니캐스트

  MAC 주소를 사용하는 일대일 통신. 자신의 MAC 주소와 동일하지 않으면 무시하기 때문에 CPU 성능을 저하시키지 않음

- 브로드캐스트

  같은 네트워크 상의 모든 장비들에게 보내는 통신. 메세지를 받는 과정에서 CPU 를 사용하기 때문에 과도한 사용은 CPU 성능을 저하시킬 수 있음.

  주로 상대의 IP는 알지만 MAC 주소를 모를 경우에 사용

- 멀티캐스트

  특정 그룹에게만 보내는 통신. 라우터가 멀티캐스트를 지원해야한다.

# UDP

# HTTP

웹에서 서버와 클라이언트가 메세지를 교환하는 방식을 정의하는 프로토콜

상태가 없는 (stateless) 연결

HTTP/2 까지는 전송 프로토콜로 TCP를 사용한다.

지속연결과 비지속연결 모두 가능하며 지속연결을 기본으로 사용한다.

지속연결 : 일정한 시간 내에 일어나는 여러 요청들에 대한 응답을 하나의 TCP 연결로 보내는 것.

비지속연결 : 모든 요청에 대한 응답을 다른 TCP 연결로 보내는 것. TCP 버퍼와 TCP 변수를 매번 새로 설정해야하기 때문에 시간이 오래걸리고 오버헤드가 크다.

## HTTP 메소드 종류와 역할

GET : 리소스 조회

POST : 데이터 처리 요청

PUT : 리소스를 대체, 해당 리소스가 없으면 생성

PATCH : 리소스를 일부만 변경

DELETE : 리소스 삭제

HEAD : GET 과 비슷하지만 body 부분을 제외하고, 응답 상태와 헤더만 반환 (디버깅에 쓰임)

## HTTP 버전별 차이 (/1.0 /1.1 /2 /3)

- 1.0

  Method : GET, HEAD, POST

  Connection : 응답 직후 종료

  비지속 연결을 기본값으로 사용하여 모든 응답에 새로운 TCP 연결이 생성된다.

  Connection 헤더에 keep-alive 를 넣어 지속연결을 사용할 수 있다.

- 1.1

  Method: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS

  Connection : long-lived

  지속 연결을 기본으로 사용하여 연속되는 요청에 대한 응답으로 같은 TCP 연결을 사용할 수 있다.

  pipelining : 클라이언트가 여러 요청을 보낼 때 응답을 기다리지 않고 요청을 보낼 수 있다.

  mutiple connections : TCP 다중연결을 통해 동시에 요청을 보낼 수 있다.

- 2

  1.1을 기반으로 성능향상이 이뤄졌다.

  같은 TCP 연결에서 다중 요청과 응답이 가능하다. 응답은 순서와 상관없이 주고받는다.

  server push : 클라이언트가 요청하지 않은 리소스를 서버가 사전에 전송할 수 있다. 요청을 보낼 것이라고 예측되는 리소스를 미리 전송

## 쿠키와 세션

HTTP는 상태를 저장하지 않는 프로토콜이다. 이로 인해서 서버가 한번에 많은 요청을 받을 수 있다는 장점이 있지만, 서버에서 사용자를 식별할 필요가 있을 때가 있다. 그럴 때 사용하는 것이 쿠키와 세션이다.

- 쿠키
  사용자에 대한 정보를 브라우저에 저장하게 하고, 사용자가 웹사이트에 접속할때 쿠키를 같이 전송하게 해서 사용자를 식별하고 사용자 맞춤 서비스를 제공할 수 있다.

- 세션
  쿠키에 저장된 세션 아이디를 기반으로 사용자를 구별한다. 하지만 쿠키와 달리 사용자 정보를 서버에 저장한다. 일정한 기간동안이나 브라우저를 닫을 때 까지 세션을 유지한다. 사용자 정보를 서버에 저장하기 때문에 쿠키만 사용하는 것에 비해 보안이 우수하지만, 서버에 저장해야하기 때문에 서버의 부담이 크다는 단점이 있다.

## HTTPS

HTTP 는 암호화되지 않았기 때문에 제 3자가 정보를 조회할 경우 중요한 정보가 탈취될 수 있다.

HTTPS 는 이러한 문제를 해결하기 위해 등장한, HTTP에 데이터 암호화를 추가한 프로토콜이다.

연결 과정에서 서버는 CA로부터 발급 받은 인증서를 클라이언트에게 전달한다.

클라이언트는 인증서의 유효성을 확인하고 서버의 공개키를 획득한다.

서버의 공개키를 통해 암호화 세션키를 만들어 서버에게 전달한다.

서버는 비밀키를 통해 세션키를 획득한다.

이후 연결이 유지되는 동안 세션키를 통해서 데이터를 암호화해 주고받는다.

대칭키(세션키)만 사용하지 않는 이유 : 세션키를 교환하는 과정에서 탈취당할 수 있기 때문에

비대칭키만 사용하지 않는 이유 : 연산 시간이 오래걸리기 때문

# 기타

## 흐름제어 / 혼잡제어 / 오류제어

## 로드 밸런싱

서버에 가해지는 부하를 분산해주는 기술

scale - up : 서버 자체의 성능을 향상 시키는 것

scale - out : 서버를 증설하는 것

scale - out 을 한다면 트래픽을 균등하게 분배해주는 로드 밸런싱이 필수이다.

## REST API

## REAT ful

## CORS

## 웹서버와 WAS의 차이

## ARP, DHCP 프로토콜

- ARP
  IP 주소를 MAC 주소로 바꾸는 프로토콜

- DHCP
  유무선 IP 환경에서 단말의 IP 주소, 서브넷 마스크(Subnet Mask), 디폴트 게이트웨이(Default Gateway) , IP 주소, DNS 서버 IP 주소, 임대기간(Lease Time) 등의 다양한 네트워크 정보를 DHCP 서버가 PC와 같은 이용자 단말에 자동으로 할당해 주는 프로토콜
